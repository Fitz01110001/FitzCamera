package com.fitz.fitzcamera;

import android.Manifest;
import android.app.Activity;
import android.content.Context;
import android.content.pm.PackageManager;
import android.content.res.Configuration;
import android.graphics.Bitmap;
import android.graphics.ImageFormat;
import android.graphics.Point;
import android.graphics.Rect;
import android.graphics.SurfaceTexture;
import android.hardware.camera2.CameraAccessException;
import android.hardware.camera2.CameraCaptureSession;
import android.hardware.camera2.CameraCharacteristics;
import android.hardware.camera2.CameraDevice;
import android.hardware.camera2.CameraManager;
import android.hardware.camera2.CaptureFailure;
import android.hardware.camera2.CaptureRequest;
import android.hardware.camera2.CaptureResult;
import android.hardware.camera2.TotalCaptureResult;
import android.hardware.camera2.params.StreamConfigurationMap;
import android.media.ImageReader;
import android.os.Build;
import android.os.Handler;
import android.os.HandlerThread;
import android.util.Log;
import android.util.Size;
import android.util.SparseIntArray;
import android.view.Surface;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.core.app.ActivityCompat;
import androidx.core.content.ContextCompat;

import com.fitz.fitzcamera.fragments.CommonCap;
import com.fitz.fitzcamera.ui.AutoFitTextureView;

import java.util.Arrays;
import java.util.HashMap;

/**
 * Manager capture
 */
public class CamManager {

    private String TAG = "CamManager";

    /**
     * Conversion from screen rotation to JPEG orientation.
     */
    private static final SparseIntArray ORIENTATIONS = new SparseIntArray();

    static {
        ORIENTATIONS.append(Surface.ROTATION_0, 90);
        ORIENTATIONS.append(Surface.ROTATION_90, 0);
        ORIENTATIONS.append(Surface.ROTATION_180, 270);
        ORIENTATIONS.append(Surface.ROTATION_270, 180);
    }

    /**
     * An additional thread for running tasks that shouldn't block the UI.
     */
    private HandlerThread mBackgroundThread;

    /**
     * A {@link Handler} for running tasks in the background.
     */
    private Handler mBackgroundHandler;

    /**
     * {@link CaptureRequest.Builder} for the camera preview
     */
    private CaptureRequest.Builder mPreviewRequestBuilder;

    /**
     * {@link CaptureRequest} generated by {@link #mPreviewRequestBuilder}
     */
    private CaptureRequest mPreviewRequest;

    /**
     * An {@link ImageReader} that handles still image capture.
     */
    private ImageReader mImageReader;

    /**
     * 获取照片名
     */
    private String imageName;

    /**
     * The FW CameraManager.
     */
    private CameraManager mCameraManager;

    /**
     * ID of the current {@link CameraDevice}.
     */
    private String mCameraId;

    /**
     * 默认后置主摄
     */
    private String mDefaultCameraId = "0";

    private final String deviceModeLG = "LM-X625N";

    private final String deviceModeHW = "LYA-AL00";

    private String currentDeviceMode = deviceModeLG;

    private final HashMap<String, String> deviceWideCameraIdMap = new HashMap<String, String>() {
        {
            put(deviceModeLG, "2");
            put(deviceModeHW, "3");
        }
    };

    private final HashMap<String, Float> deviceWideCameraZoomDiff = new HashMap<String, Float>() {
        {
            put(deviceModeLG, 0.4f);
            put(deviceModeHW, 0.8f);
        }
    };

    /**
     * 广角镜头id，LG：2 HW：3
     */
    private final String mWideCameraId = deviceWideCameraIdMap.get(currentDeviceMode);

    /**
     * 广角和主摄之间的zoom差值
     */
    private final Float zoomDiff = deviceWideCameraZoomDiff.get(currentDeviceMode);

    private Activity mContext;

    private CameraInfoCallback mCameraInfoCallback;

    private Rect mSensorRect;

    /**
     * 当前zoom值
     */
    private Rect mCurrentRect;

    private float mMaxZoom = 1.0f;

    private float mCurrentZoom = 1.0f;

    private final float defaultZoomRatio = 1.0f;

    private CameraDevice mCameraDevice;

    private CameraCharacteristics mCameraCharacteristics;

    private Surface surface;

    private CameraCaptureSession mCameraCaptureSession;

    /**
     * Max preview width that is guaranteed by Camera2 API
     */
    private static final int MAX_PREVIEW_WIDTH = 1920;

    /**
     * Max preview height that is guaranteed by Camera2 API
     */
    private static final int MAX_PREVIEW_HEIGHT = 1080;

    /**
     * The {@link android.util.Size} of camera preview.
     */
    private Size mPreviewSize;

    /**
     * Orientation of the camera sensor
     */
    private int mSensorOrientation;

    /**
     * 默认4:3比例
     */
    private static Size mDefaultSize;

    private AutoFitTextureView mTextureView;

    public CamManager(CommonCap fg, Activity context) {
        mContext = context;
        mCameraManager = (CameraManager) mContext.getSystemService(Context.CAMERA_SERVICE);
        startBackgroundThread();
    }

    public String[] getCameraIDList() {
        try {
            return mCameraManager.getCameraIdList();
        } catch (CameraAccessException e) {
            e.printStackTrace();
        }
        return null;
    }

    public void checkCameraPermission() {
        if (ContextCompat.checkSelfPermission(mContext, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED || ContextCompat
                .checkSelfPermission(mContext, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
            requestCameraPermission();
        }
    }

    private void requestCameraPermission() {
        ActivityCompat.requestPermissions(mContext, new String[]{Manifest.permission.CAMERA, Manifest.permission.WRITE_EXTERNAL_STORAGE}, 1);
    }

    /**
     * 获取 cameraID 对应支持的分辨率
     */
    private void getCamInfo() {
        CameraCharacteristics cameraCharacteristics = null;
        try {
            for (String cameraId : mCameraManager.getCameraIdList()) {
                cameraCharacteristics = mCameraManager.getCameraCharacteristics(cameraId);
                StreamConfigurationMap map = cameraCharacteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);

                StringBuilder sb = new StringBuilder();
                sb.append("cameraID:")
                  .append(cameraId)
                  .append("\n");
                /*for (Size s : Arrays.asList(map.getOutputSizes(ImageFormat.JPEG))) {
                    sb.append(s.toString())
                      .append("\n");
                }*/
                sb.append("mSensorRect:")
                  .append(mSensorRect.toString())
                  .append("\n")
                  .append("mMaxZoom:")
                  .append(mMaxZoom);
                Log.d(TAG, "CamInfo: " + sb.toString());


            }
        } catch (CameraAccessException e) {
            e.printStackTrace();
        }
    }

    private void setupImageReader(Size s) {
        mImageReader = ImageReader.newInstance(s.getWidth(), s.getHeight(), ImageFormat.JPEG, /*maxImages*/2);
        mImageReader.setOnImageAvailableListener(mOnImageAvailableListener, mBackgroundHandler);
    }

    /**
     * Closes the current {@link CameraDevice}.
     */
    private void closeCamera() {
        if (null != mCameraCaptureSession) {
            try {
                mCameraCaptureSession.stopRepeating();
            } catch (CameraAccessException e) {
                e.printStackTrace();
            }
            mCameraCaptureSession.close();
            mCameraCaptureSession = null;
        }
        if (null != mCameraDevice) {
            mCameraDevice.close();
            mCameraDevice = null;
        }
        if (null != mImageReader) {
            mImageReader.close();
            mImageReader = null;
        }
    }

    public void onPause() {
        closeCamera();
        //stopBackgroundThread();
    }

    public String takeShot() {
        imageName = SaveImage.getImageName();
        Log.d(TAG, "imageName" + imageName);
        sendShotRequest();
        return imageName;
    }

    private void sendShotRequest() {
        Log.d(TAG, "sendShotRequest");
        try {
            CaptureRequest.Builder captureBuilder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_STILL_CAPTURE);
            captureBuilder.addTarget(mImageReader.getSurface());
            // Orientation
            int rotation = mContext.getWindowManager()
                                   .getDefaultDisplay()
                                   .getRotation();
            captureBuilder.set(CaptureRequest.JPEG_ORIENTATION, getOrientation(rotation));
            setZoomRation(captureBuilder);
            mCameraCaptureSession.capture(captureBuilder.build(), mCaptureCallback, mBackgroundHandler);
        } catch (CameraAccessException e) {
            e.printStackTrace();
        }
    }

    private void setZoomRation(CaptureRequest.Builder captureBuilder) {
        captureBuilder.set(CaptureRequest.SCALER_CROP_REGION, mCurrentRect);
    }

    /**
     * Retrieves the JPEG orientation from the specified screen rotation.
     *
     * @param rotation The screen rotation.
     * @return The JPEG orientation (one of 0, 90, 270, and 360)
     */
    private int getOrientation(int rotation) {
        // Sensor orientation is 90 for most devices, or 270 for some devices (eg. Nexus 5X)
        // We have to take that into account and rotate JPEG properly.
        // For devices with orientation of 90, we simply return our mapping from ORIENTATIONS.
        // For devices with orientation of 270, we need to rotate the JPEG 180 degrees.
        return (ORIENTATIONS.get(rotation) + mSensorOrientation + 270) % 360;
    }

    /**
     * Starts a background thread and its {@link Handler}.
     */
    private void startBackgroundThread() {
        mBackgroundThread = new HandlerThread("CameraBackground");
        mBackgroundThread.start();
        mBackgroundHandler = new Handler(mBackgroundThread.getLooper());
    }

    /**
     * Stops the background thread and its {@link Handler}.
     */
    private void stopBackgroundThread() {
        if (mBackgroundThread != null) {
            mBackgroundThread.quitSafely();
            try {
                mBackgroundThread.join();
                mBackgroundThread = null;
                mBackgroundHandler = null;
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * This a callback object for the {@link ImageReader}. "onImageAvailable" will be called when a
     * still image is ready to be saved.
     */
    private final ImageReader.OnImageAvailableListener mOnImageAvailableListener = new ImageReader.OnImageAvailableListener() {

        @Override
        public void onImageAvailable(ImageReader reader) {
            Log.d(TAG, "onImageAvailable");
            mBackgroundHandler.post(new SaveImage(reader.acquireNextImage(), imageName));
        }

    };

    /**
     * 获取当前 textureview 显示位图。此处用于获取切换镜头时的最后一帧。
     */
    public void getLastFrame(Bitmap bitmap) {
        mBackgroundHandler.post(new SaveImage(bitmap, SaveImage.getImageName()));
    }

    /**
     * open camera with given id
     */
    public void openCamera(AutoFitTextureView textureView) {
        mTextureView = textureView;
        try {
            for (String cameraId : mCameraManager.getCameraIdList()) {
                mCameraCharacteristics = mCameraManager.getCameraCharacteristics(cameraId);
                if (mCameraCharacteristics.get(CameraCharacteristics.LENS_FACING) == CameraCharacteristics.LENS_FACING_BACK) {
                    mDefaultCameraId = cameraId;
                    mCameraId = cameraId;
                    openCamera(mCameraId);
                    return;
                }
            }
        } catch (CameraAccessException e) {
            e.printStackTrace();
        }
    }

    private void openCamera(String cameraId) {
        mCameraId = cameraId;

        try {
            mCameraCharacteristics = mCameraManager.getCameraCharacteristics(mCameraId);
            if (mCameraInfoCallback != null) {
                mCameraInfoCallback.cameraFacing(mCameraCharacteristics.get(CameraCharacteristics.LENS_FACING));
            }
            setUpCameraOutputs();
            if (ContextCompat.checkSelfPermission(mContext, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) {
                requestCameraPermission();
            } else {
                Log.d(TAG, "open cameraid:" + mCameraId);
                mCameraManager.openCamera(mCameraId, mDeviceStateCallback, mBackgroundHandler);
            }
        } catch (CameraAccessException e) {
            e.printStackTrace();
        }

    }

    /**
     * 获取一些camera信息
     */
    private void setUpCameraOutputs() {
        mSensorRect = mCameraCharacteristics.get(CameraCharacteristics.SENSOR_INFO_ACTIVE_ARRAY_SIZE);
        mMaxZoom = mCameraCharacteristics.get(CameraCharacteristics.SCALER_AVAILABLE_MAX_DIGITAL_ZOOM);
        mCurrentRect = cropRegionForZoom(defaultZoomRatio);
        setupTextureView();
    }

    /**
     * 計算預覽尺寸
     */
    private void setupTextureView() {
        StreamConfigurationMap map = mCameraCharacteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);
        //取第一个值，为默认分辨率
        mDefaultSize = Arrays.asList(map.getOutputSizes(ImageFormat.JPEG))
                             .get(0);
        Log.d(TAG, "W: " + mDefaultSize.getWidth() + " H: " + mDefaultSize.getHeight());
        setupImageReader(mDefaultSize);
        // Find out if we need to swap dimension to get the preview size relative to sensor
        // coordinate.
        int displayRotation = mContext.getWindowManager()
                                      .getDefaultDisplay()
                                      .getRotation();
        //noinspection ConstantConditions
        mSensorOrientation = mCameraCharacteristics.get(CameraCharacteristics.SENSOR_ORIENTATION);
        boolean swappedDimensions = false;
        switch (displayRotation) {
            case Surface.ROTATION_0:
            case Surface.ROTATION_180:
                if (mSensorOrientation == 90 || mSensorOrientation == 270) {
                    swappedDimensions = true;
                }
                break;
            case Surface.ROTATION_90:
            case Surface.ROTATION_270:
                if (mSensorOrientation == 0 || mSensorOrientation == 180) {
                    swappedDimensions = true;
                }
                break;
            default:
                Log.e(TAG, "Display rotation is invalid: " + displayRotation);
        }
        //camera 输出分辨率可能大于屏幕支持范围！！！
        Point displaySize = new Point();
        mContext.getWindowManager()
                .getDefaultDisplay()
                .getSize(displaySize);
        int rotatedPreviewWidth = mDefaultSize.getWidth();
        int rotatedPreviewHeight = mDefaultSize.getHeight();
        int maxPreviewWidth = displaySize.x;
        int maxPreviewHeight = displaySize.y;

        Log.d(TAG, "maxPreviewWidth:" + maxPreviewWidth + " maxPreviewHeight:" + maxPreviewHeight);
        Log.d(TAG, "swappedDimensions:" + swappedDimensions);

        if (swappedDimensions) {
            rotatedPreviewWidth = mDefaultSize.getHeight();
            rotatedPreviewHeight = mDefaultSize.getWidth();
            maxPreviewWidth = displaySize.y;
            maxPreviewHeight = displaySize.x;
        }

        if (maxPreviewWidth > MAX_PREVIEW_WIDTH) {
            maxPreviewWidth = MAX_PREVIEW_WIDTH;
        }

        if (maxPreviewHeight > MAX_PREVIEW_HEIGHT) {
            maxPreviewHeight = MAX_PREVIEW_HEIGHT;
        }

        mPreviewSize = calPreviewSize(maxPreviewWidth, maxPreviewHeight, rotatedPreviewWidth, rotatedPreviewHeight);

        // We fit the aspect ratio of TextureView to the size of preview we picked.
        int orientation = mContext.getResources()
                                  .getConfiguration().orientation;
        if (orientation == Configuration.ORIENTATION_LANDSCAPE) {
            mTextureView.setAspectRatio(mPreviewSize.getWidth(), mPreviewSize.getHeight());
        } else {
            mTextureView.setAspectRatio(mPreviewSize.getHeight(), mPreviewSize.getWidth());
        }
        mDefaultSize = mPreviewSize;
        Log.d(TAG, "mW: " + mPreviewSize.getWidth() + " mH: " + mPreviewSize.getHeight());
    }

    private Size calPreviewSize(int maxPreviewWidth, int maxPreviewHeight, int rotatedPreviewWidth, int rotatedPreviewHeight) {
        Log.d(TAG, maxPreviewWidth + " " + maxPreviewHeight + " " + rotatedPreviewWidth + " " + rotatedPreviewHeight);
        if (rotatedPreviewWidth >= maxPreviewWidth || rotatedPreviewHeight >= maxPreviewHeight) {
            //照片尺寸大于屏幕，需要等比例缩小预览尺寸
            //取小的一边为基数
            float proportion = (float) rotatedPreviewHeight / (float) rotatedPreviewWidth;
            Log.d(TAG, "proportion:" + proportion);
            if (maxPreviewWidth <= maxPreviewHeight) {
                maxPreviewHeight = (int) (proportion * maxPreviewHeight);
            } else {
                maxPreviewWidth = (int) (proportion * maxPreviewHeight);
            }
        }
        return new Size(maxPreviewWidth, maxPreviewHeight);
    }

    /**
     * camera device onOpened state callback
     */
    private CameraDevice.StateCallback mDeviceStateCallback = new CameraDevice.StateCallback() {
        @Override
        public void onOpened(@NonNull CameraDevice camera) {
            mCameraDevice = camera;
            createCameraPreviewSession();
        }

        @Override
        public void onDisconnected(@NonNull CameraDevice camera) {

        }

        @Override
        public void onError(@NonNull CameraDevice camera, int error) {

        }
    };

    /**
     * Creates a new {@link CameraCaptureSession} for camera preview.
     */
    private void createCameraPreviewSession() {
        Log.d(TAG, "createCameraPreviewSession");
        try {
            SurfaceTexture texture = mTextureView.getSurfaceTexture();

            // We configure the size of default buffer to be the size of camera preview we want.
            texture.setDefaultBufferSize(mDefaultSize.getWidth(), mDefaultSize.getHeight());

            // This is the output Surface we need to start preview.
            surface = new Surface(texture);

            // We set up a CaptureRequest.Builder with the output Surface.
            mPreviewRequestBuilder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);
            mPreviewRequestBuilder.addTarget(surface);

            // Here, we create a CameraCaptureSession for camera preview.
            mCameraDevice.createCaptureSession(Arrays.asList(surface, mImageReader.getSurface()), new CameraCaptureSession.StateCallback() {

                @Override
                public void onConfigured(@NonNull CameraCaptureSession cameraCaptureSession) {
                    Log.d(TAG, "onConfigured");
                    // The camera is already closed
                    if (null == mCameraDevice) {
                        return;
                    }

                    // When the session is ready, we start displaying the preview.
                    mCameraCaptureSession = cameraCaptureSession;
                    // Auto focus should be continuous for camera preview.
                    mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AF_MODE, CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE);
                    if (mCameraInfoCallback != null) {
                        mCameraInfoCallback.cameraDeviceOnConfigured(mPreviewRequestBuilder);
                    }
                    setRepeatingPreview();
                }

                @Override
                public void onConfigureFailed(@NonNull CameraCaptureSession cameraCaptureSession) {
                }
            }, null);
        } catch (CameraAccessException e) {
            e.printStackTrace();
        }
    }

    /**
     * 发起重复预览请求
     */
    private void setRepeatingPreview() {
        // Finally, we start displaying the camera preview.
        mPreviewRequest = mPreviewRequestBuilder.build();
        try {
            if (mCameraCaptureSession != null) {
                mCameraCaptureSession.setRepeatingRequest(mPreviewRequest, mCaptureCallback, mBackgroundHandler);
            }
        } catch (CameraAccessException e) {
            e.printStackTrace();
        }
    }

    /**
     * preview callback
     */
    private CameraCaptureSession.CaptureCallback mCaptureCallback = new CameraCaptureSession.CaptureCallback() {

        @Override
        public void onCaptureStarted(@NonNull CameraCaptureSession session, @NonNull CaptureRequest request, long timestamp, long frameNumber) {
            super.onCaptureStarted(session, request, timestamp, frameNumber);

        }


        @Override
        public void onCaptureProgressed(@NonNull CameraCaptureSession session, @NonNull CaptureRequest request,
                                        @NonNull CaptureResult partialResult) {
            super.onCaptureProgressed(session, request, partialResult);

        }


        @Override
        public void onCaptureCompleted(@NonNull CameraCaptureSession session, @NonNull CaptureRequest request, @NonNull TotalCaptureResult result) {
            super.onCaptureCompleted(session, request, result);


        }

        @Override
        public void onCaptureSequenceAborted(@NonNull CameraCaptureSession session, int sequenceId) {
            super.onCaptureSequenceAborted(session, sequenceId);
            Log.d(TAG, "onCaptureSequenceAborted");
        }

        @Override
        public void onCaptureBufferLost(@NonNull CameraCaptureSession session, @NonNull CaptureRequest request, @NonNull Surface target, long frameNumber) {
            super.onCaptureBufferLost(session, request, target, frameNumber);
            Log.d(TAG, "onCaptureBufferLost");
        }

        @Override
        public void onCaptureSequenceCompleted(@NonNull CameraCaptureSession session, int sequenceId, long frameNumber) {
            super.onCaptureSequenceCompleted(session, sequenceId, frameNumber);
            Log.d(TAG, "onCaptureSequenceCompleted");
        }

        @Override
        public void onCaptureFailed(@NonNull CameraCaptureSession session, @NonNull CaptureRequest request, @NonNull CaptureFailure failure) {
            super.onCaptureFailed(session, request, failure);
        }
    };

    /**
     * Calculates sensor crop region for a zoom level (zoom >= 1.0).
     *
     * @param ratio the zoom level.
     * @return Crop region.
     */
    private Rect cropRegionForZoom(float ratio) {
        Log.d(TAG, "ratio:" + ratio);
        int xCenter = mSensorRect.width() / 2;
        int yCenter = mSensorRect.height() / 2;
        int xDelta = (int) (0.5f * mSensorRect.width() / ratio);
        int yDelta = (int) (0.5f * mSensorRect.height() / ratio);
        /*Log.d(TAG, "xCenter:" + xCenter);
        Log.d(TAG, "yCenter:" + yCenter);
        Log.d(TAG, "xDelta:" + xDelta);
        Log.d(TAG, "yDelta:" + yDelta);*/
        return new Rect(xCenter - xDelta, yCenter - yDelta, xCenter + xDelta, yCenter + yDelta);
    }

    /**
     * 控制缩放逻辑,根据UI进度实时zoom
     * */
    public void setZoomRatioInLG(float zoomRatio) {
        Log.d(TAG, mCameraId + " zoomRatio:" + zoomRatio);
        if (!mCameraId.equals(mWideCameraId) && zoomRatio >= 1.0f) {
            //非广角镜头的zoom
            mCurrentRect = cropRegionForZoom(zoomRatio);
            mPreviewRequestBuilder.set(CaptureRequest.SCALER_CROP_REGION, mCurrentRect);
            setRepeatingPreview();
        } else if (!mCameraId.equals(mWideCameraId) && zoomRatio < 1.0f) {
            //非广角镜头zoom到1.0以下，应切换到广角。并在启动广角时，设置zoom=1+zoomdiff
            switchCamera(mWideCameraId, new CameraInfoCallback() {
                @Override
                public void cameraFacing(int facing) {

                }

                @Override
                public void cameraDeviceOnConfigured(CaptureRequest.Builder builder) {
                    Log.d(TAG, "builder.set zoomDiff");
                    mCurrentRect = cropRegionForZoom(1 + zoomDiff);
                    builder.set(CaptureRequest.SCALER_CROP_REGION, mCurrentRect);
                }
            });
        } else if (mCameraId.equals(mWideCameraId) && zoomRatio >= 1.0f) {
            //广角镜头zoom到1X以上，广角镜头切到主摄
            switchCamera(mDefaultCameraId, null);
        } else if (mCameraId.equals(mWideCameraId) && zoomRatio < 1.0f) {
            //广角镜头下zoom,广角镜头zoom范围也是 1.0~max,zoomRatio需要换算
            zoomRatio += zoomDiff;
            mCurrentRect = cropRegionForZoom(zoomRatio);
            mPreviewRequestBuilder.set(CaptureRequest.SCALER_CROP_REGION, mCurrentRect);
            setRepeatingPreview();
        }
    }

    public void setZoomRatioInHW(float zoomRatio) {
        Log.d(TAG, mCameraId + " zoomRatio:" + zoomRatio);
        mCurrentRect = cropRegionForZoom(zoomRatio);
        mPreviewRequestBuilder.set(CaptureRequest.SCALER_CROP_REGION, mCurrentRect);
        setRepeatingPreview();
    }

    /**
     * 仿LG的平滑控制
     * */
    public void zoom(float zoomRatio){
        if(currentDeviceMode.equals(deviceModeLG)){
            setZoomRatioInLG(zoomRatio);
        }else if(currentDeviceMode.equals(deviceModeHW)){
            setZoomRatioInHW(zoomRatio);
        }
    }

    public void switchCamera(String cameraId, @Nullable CameraInfoCallback cameraInfoCallback) {
        mCameraInfoCallback = cameraInfoCallback;
        closeCamera();
        openCamera(cameraId);
    }

    /**
     * 用于给UI回调camera信息
     */
    public interface CameraInfoCallback {
        void cameraFacing(int facing);

        void cameraDeviceOnConfigured(CaptureRequest.Builder builder);
    }

    public void getDeviceInfo(){
        String str1 = Build.MODEL;
        String str2 = android.os.Build.BRAND;
        currentDeviceMode = str1;
        Log.d(TAG,"MODEL:"+str1);
        Log.d(TAG,"BRAND:"+str2);
    }
}
